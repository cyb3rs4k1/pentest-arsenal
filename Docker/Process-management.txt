Container basics commands :

1) Check version:

Command : ctr --version

2) Pulling image

Command : ctr images pull --skip-verify --plain-http registry:5000/alpine:latest

3) List images

ctr images list

4) Create container

ctr container create registry:5000/alpine:latest alpine

5) List containers

ctr container list

6) Check container info

ctr container info alpine (can be provided other names)

7) Start a task :

ctr task start alpine

8) Attach to a task

ctr task attach alpine

9) List tasks

ctr task list

10) Pause a task

ctr task pause alpine

11) Resume a task

ctr tasks resume alpine

12) Kill a task

ctr task kill -s SIGKILL alpine

13) Delete a container

ctr container delete alpine

14) Export image as tar archive
ctr image list

ctr image export alpine.tar registry:5000/alpine:latest

15) Push image

ctr image push --skip-verify --plain-http registry:5000/alpine-latest

16) Remove image

ctr image rm

-----------------------------------------------------------------

Podman basics lab:

1) Check podman version

podman --version

2) Check host information :

podman info

3) Pull image

podman pull registry:5000/alpine

4) List images

podman images

5) Run image in background mode

podman run -dt registry:5000/alpine

6) Run image in interactive mode

podman run -it registry:5000/alpine sh

7) List running containers:

podman ps

8) Inspect a container

podman inspect <container id>

9) Manage containers:

podman container --help

10) Manage images

podman image --help

11) List networks

podman network ls

12) Manage networks

podman network --help

13) Attach to a running container

podman attach <container id>

14) Execute a command in a running container

podman exec -it <container id>

15) Stop a running container

podman stop <container id>

16) Kill a running container

podmain kill <container id>

17) Build podman image

Create a containerfile named containerfile.

```
FROM registry:5000/alpine:latest

COPY script /root/

RUN chmod +x /root/script
```

This containerfile takes locally present alpine image as base and copies a script in it.

Create a dummy script named script
```
Dummy script
```

Command : podman build -t registry:5000/alpine-mod -f containerfile .

19) Push the image

podman push registry:5000/alpine-mod

20) Commit container as an image

Create a container by running an image. Make some changes to it

podman run -it registry:5000/alpine sh

/ # 
/ # cd /root/
~ # 
~ # echo "We want to save this change" > note.txt
~ # 
~ # cat note.txt
We want to save this change
~ # 


Here, a text file is created in it. Now, commit it.

Command : podman commit <container id> registry:5000/alpine-note

21) Export an image as tar archige

podman ps

podman export -o alpine.tar <image id>

ls -l

22) Remove stopped containers

List all running and stopped containers

podman ps -a

Take container IDs of desired contaienrs and delete them

podmain rm <containerid1> <containerid2> <containerid3> <etc>

23) Remove an image

List all images present in the local storage

podman images

Remove image by name

command: podman rmi -f registry:5000/alpine-note

Remove image by Image ID

Command: podmain rmi -f <imageid>

Check the image list to verify the deletion

podman images

24) Remove stopped container, unused images/networks

podman system prune -a


------------------------------------------------------------------

Containers using Runc

1) Fetch the image and run it using runc

Solution:

Step 1: Check the list of repos on docker repository.

Command: curl --insecure https://registry:5000/v2/_catalog

There are four repositories.

Step 2: Check the tags for "alpine" repository.

command : curl -- insecure https://registry:5000/v2/alpine/tags/list

step 3: Pull "alpine:latest" docker image using skopeo and save it in OCI format

Commands: skepeo --insecure-policy copy --src-tls-verify=false docker://registry:5000/alpine oci:alpine-oci:latest

Step 4: Check the image stored in OCI format

Commands:

ls -l
find alpine-oci

Step 5: Use umoci to convert OCI image to image bundle

Command : umoci unpack --image alpine -oci alpinefs

Step 6: Use the image bundle to create and run container using runc

Command : runc run -b alpinefs ctrid

---------------------------------------------------

Multicontainer setups

Step 1 : Pull the both docker images

Command : docker pull registry:5000/appserver

Command : docker pull registry:5000/memcached-app

Step 2 : Check the locally present image list.

Command : docker images

Step 3 : Create a network named "test-net"

Command : docker network create test-net

Verify if the network is created

Command : docker network ls

Step 4: Run the appserver images first and attach test-net to it

Command : docker run --network test-net -d registry:5000/appserver

Now, similarly run the memcached image

Command : docker run --network test-net -d registry:5000/memcached-app

Step 5: Check the running containers

Command : docker ps

Step 6 : Check the IP address for the appserver container

Command : docker insepct <containerid> | grep IP

Step 7: Make a curl request on this IP to see if we can access the HTTP API for memcached

Command : curl <IP>

Step 8: Stop both containers

Command : docker stop <container1> <container2>

Also delete the test-net network

Command : docker network rm test-net

Docker Compose method

Step 9: Create a docker-compose.yaml and describe this scenario

docker-compose.yaml
```
version: "3.5"
services:
	appserver:
		image: registry:5000/appserver
		networks:
			- backend
	memcache:
		image: registry:5000/memcached-app
		networks:
			- backend
		depends_on:
			- appserver
	networks:
		backend:
			name: test-net2
			driver: bridge
```

Step 9 : Use docker-compose to create the setup

Command : docker-compose up

Note : Make sure the docker-compose.yaml is present in the working directory..

Step 10: Open another terminal(by clicking the lab link button again) check the IP address for the appserver container.

Then, make a curl request on this IP to see if we can access the HTTP API for memcached

Command : curl 172.20.0.2

Step 11: Use the curl request to store an item to the memcached and retrieve it

Store an term

Command : curl "172.20.0.2/set?key=a&value=test"

Retrieve that item

Command : curl "172.20.0.2/get?key=a"

Step 12 : Destroy the setup

Command : docker-compose down

---------------------------------------------------------------

Cgroups

Cgroups or Control Groups are a Linux kernel feature to monitor and limit the resource usage of a process or a group of processes.

Read more: https://man7.org/linux/man-pages/man7/cgroups.7.html

To test the functionality of cgroup restrictions, we will use eatmemory, a memory eating utility.

Github: https://github.com/julman99/eatmemory

Step 1: Check the content of the home directory of the root user.

Command: ls /root

Step 2: Switch to the eatmemory directory and list the contents.

Commands:

cd eatmemory
ls -l

Step 3: Run make utility to build the binary and check if the binary is created.

Commands:

make
ls -l

Step 4: Execute the binary and check the help menu.

Command: ./eatmemory -h

Step 5: Run the binary to consume 2 GB of memory.

Command: ./eatmemory 2G

One can observe that the memory was consumed and eatmemory is still running (before we terminated it with Ctrl+C).

Step 6: Create a memory cgroup named “test”.

Command: cgcreate -g memory:test

Step 7: Set memory limit of 4 MB to this cgroup.

Command: cgset -r memory.limit_in_bytes=4194304 test

Step 8 : Execute eatmemory to consume 2 GB memory but this time, confine it with “test” cgroup.

Command: cgexec -g memory:test ./eatmemory 2G

One can observe that eatmemory program got killed. This is because it tried to eat more memory (i.e. 2 GB) than allowed by the “test” cgroup (i.e. 4 MB).

Step 9: Try with 4 MB (equals to allowed cgroup memory limit).

Command: cgexec -g memory:test ./eatmemory 4M

The program still got killed. Most probably because it tried to eat 4 MB and the program itself must be consuming some memory to run, hence taking total memory consumption by this process beyond 4 MB.

Step 10: Try with 3 MB.

Command: cgexec -g memory:test ./eatmemory 3M

This time the process was not killed because it stayed in the limit of 4 MB.

NameSpaces:

Namespaces are features of Linux kernel to divide system resources into different logical partitions.
There are different namespaces supported by the kernel.

Read more: https://man7.org/linux/man-pages/man7/namespaces.7.html

We will check on the most two prominent namespaces :
1. Process ID (PID) Namespace
2. Network Namespace

PID Namespace
Create a new PID namespace that is different from the host PID namespace.

Step 1: Check existing namespaces.

Command: lsns

Step 2: Unshare command can be used to create a separate PID namespace. Check the help options for this command.

Command: unshare -h

Step 3: Create a new PID namespace with unshare command.

Command: unshare --fork --pid --mount-proc bash

And check the process IDs of processes running in this namespace.

Command: ps -ef

Observe that the bash command that was executed with unshare, is running with PID 1. That clearly shows that it is in a new PID namespace.

Step 4: Check the difference in PIDs of a process inside the newly created PID namespace and host machine. To do this, run sleep 1000 command and background it.

Command: sleep 1000 &

Check the PID of sleep command, from inside the newly created namespace

Command: ps -ef

The PID of sleep process is 14

Open a new terminal by clicking the “Lab Link” or copying the existing terminal link in a new tab.

Check the process ID for sleep 1000 process on the host Linux machine.

Command: ps -ef | grep sleep

The PID of sleep process is 792. One can observe the difference between the PIDs.

Step 5: List the namespaces again (on the host Linux machine) to observe the newly created namespaces.

Command: lsns

Two more namespaces are available. One of which is a PID namespace.

Network Namespace:
Create a new network namespace that is different from the host network namespace and add a dummy interface to it.

Step 1: Check existing namespaces.

Command: lsns

One network namespace (TYPE net) is present.

Step 2: Add a dummy interface.

Command: ip link add ens10 type dummy

Step 3: Verify that the interface is created

Command: ifconfig ens10

Step 4: Create a new network namespace named “testns”

Command: ip netns add testns

Step 5: List network namespaces

Command: ip netns list

Step 6: Add the dummy interface to “testns” namespace.

Command: ip link set ens10 netns testns

Step 7: Try to list the details of the dummy interface.

Command: ifconfig ens10

The listing failed because the dummy interface is moved to “testns”

Step 8: Turn the dummy interface while selecting “testns” namespace.

Command: ip netns exec testns ifconfig ens10 up

Command executed normally.

Step 9: Start a bash in “testns” namespace and list the interfaces.

Commands:

ip netns exec testns bash
ifconfig

The dummy interface can be observed in the listing.

Create Custom Container:

One will require the following components to create a Container.
- Filesystem
- Cgroup
- Namespaces

Filesystem: Use the filesystem of Alpine Linux image.

Step 1: Pull alpine image from Docker registry

Command: docker pull registry:5000/alpine

Step 2: Pull alpine image from Docker registry

Command: docker run -it registry:5000/alpine sh

Step 3: Open a new terminal and check running containers.

Command: docker ps

Step 4: Create a folder /root/filesystem and copy all files from the container.

Commands:
mkdir /root/filesystem
docker cp 61a3a709a9c8:/ filesystem/

Step 5: Check the copied filesystem.

Command: ls -l filesystem

For CGroup and Namespaces use the following script:
1 #! /bin/bash
2 cd filesystem
3 cgcreate -g cpu,cpuacct,memory:testc
4 cgset -r cpu.shares=512 testc
5 cgset -r memory.limit_in_bytes=1000000000 testc
6 cgexec -g "cpu,cpuacct,memory:testc" unshare -fmuipn --mount-proc chroot /root/filesystem /bin/sh -c "/bin/mount -t proc proc /proc && /bin/sh"

Description:
Line 1 : Bash shebang line
Line 2: Making /root/filesystem as present working directory (pwd)
Line 3: Creating a Cgroup “testc” to control memory and CPU usage
Line 4: Setting CPU usage limit for “testc”
Line 5: Setting memory limit for “testc”
Line 6: Run unshare to create new namespace while using the /root/filesystem as the filesystem and containing it with “testc” cgroup. /bin/sh is the default shell for Alpine Linux, it will be executed in this environment to give us command execution capability.

Step 6: Save the provided script as container.sh and make it executable.

Command: chmod +x container.sh

Step 7: Execute the script and run uname -a from the sh prompt.

Commands:
./container.sh
uname -a

Step 8: Execute whoami command to check the current user and check the hostname.

Command: whoami

Command: cat /etc/hostname

This is a basic container created by using an alpine filesystem and features of the host machine’s kernel (Cgroups and Namespaces).

Step 9: Open a new terminal and list the namespaces.

Command: lsns

One can see the newly created namespaces
